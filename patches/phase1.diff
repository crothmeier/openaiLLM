diff --git a/nvme_models/storage.py b/nvme_models/storage.py
index 1234567..abcdefg 100644
--- a/nvme_models/storage.py
+++ b/nvme_models/storage.py
@@ -36,6 +36,25 @@ class NVMeStorageManager:
         self.min_free_space_gb = config['storage'].get('min_free_space_gb', 50)
     
+    def _validate_path_boundary(self, path: Path, base: Path) -> bool:
+        """Validate that a path stays within base directory after resolution.
+        
+        Args:
+            path: Path to validate
+            base: Base directory that path must be within
+            
+        Returns:
+            bool: True if path is within base, False otherwise
+        """
+        try:
+            resolved_path = path.resolve()
+            resolved_base = base.resolve()
+            # Python 3.9+ has is_relative_to, for older versions use string comparison
+            return str(resolved_path).startswith(str(resolved_base) + os.sep) or resolved_path == resolved_base
+        except (OSError, RuntimeError) as e:
+            logger.error(f"Path resolution failed: {e}")
+            return False
+    
     def _safe_path_join(self, *parts: str) -> Path:
         """Safely join path components with security validation.
         
@@ -74,9 +93,17 @@ class NVMeStorageManager:
             result_path = Path(validated_parts[0])
             
             # Join remaining parts
             for part in validated_parts[1:]:
                 result_path = result_path / part
+            
+            # Validate the final path stays within base
+            if not self._validate_path_boundary(result_path, self.nvme_path):
+                raise SecurityException(
+                    f"Path escapes base directory after resolution: {result_path}"
+                )
             
             return result_path
         else:
             raise SecurityException("No path components provided to join")
@@ -170,7 +197,8 @@ class NVMeStorageManager:
             try:
                 result = subprocess.run(
                     ['mountpoint', '-q', str(self.nvme_path)],
                     capture_output=True,
                     text=True,
-                    timeout=5
+                    timeout=5,
+                    check=False  # We check returncode manually
                 )
 
@@ -179,7 +207,8 @@ class NVMeStorageManager:
                     mount_check = subprocess.run(
                         ['mount'],
                         capture_output=True,
                         text=True,
-                        timeout=5
+                        timeout=5,
+                        check=False
                     )
 
@@ -218,7 +247,8 @@ class NVMeStorageManager:
                 df_result = subprocess.run(
                     ['df', str(self.nvme_path)],
                     capture_output=True,
                     text=True,
-                    timeout=5
+                    timeout=5,
+                    check=False
                 )
 
@@ -259,7 +289,8 @@ class NVMeStorageManager:
                         lsblk_result = subprocess.run(
                             ['lsblk', '-o', 'NAME,TYPE,MOUNTPOINT', '-J'],
                             capture_output=True,
                             text=True,
-                            timeout=5
+                            timeout=5,
+                            check=False
                         )
 
@@ -392,30 +423,41 @@ class NVMeStorageManager:
             return False
 
     def _setup_environment_variables(self):
-        """Set up environment variables for model caching."""
+        """Set up environment variables for model caching.
+        
+        Note: Does not modify ~/.bashrc to respect systemd sandboxing.
+        """
         env_vars = {
             'HF_HOME': str(self._safe_path_join(self.nvme_path, 'hf-cache')),
             'TRANSFORMERS_CACHE': str(self._safe_path_join(self.nvme_path, 'hf-cache')),
             'HUGGINGFACE_HUB_CACHE': str(self._safe_path_join(self.nvme_path, 'hf-cache')),
             'OLLAMA_MODELS': str(self._safe_path_join(self.nvme_path, 'ollama'))
         }
 
         # Update current environment
         for key, value in env_vars.items():
             os.environ[key] = value
             logger.info(f"Set {key}={value}")
 
-        # Update ~/.bashrc
-        bashrc_path = Path.home() / '.bashrc'
-        if bashrc_path.exists():
-            with open(bashrc_path, 'r') as f:
-                content = f.read()
-            
-            for key, value in env_vars.items():
-                export_line = f'export {key}={value}'
-                if export_line not in content:
-                    with open(bashrc_path, 'a') as f:
-                        f.write(f'\n{export_line}')
-                    logger.info(f"Added {key} to ~/.bashrc")
+        # Write to environment file for systemd if configured
+        env_file_path = os.environ.get('NVME_MODELS_ENV_FILE')
+        if env_file_path:
+            try:
+                env_file = Path(env_file_path)
+                # Validate path is safe
+                if not self._validate_path_boundary(env_file, Path('/etc')):
+                    logger.warning(f"Environment file path outside /etc: {env_file_path}")
+                    return
+                
+                with open(env_file, 'w') as f:
+                    for key, value in env_vars.items():
+                        f.write(f'{key}={value}\n')
+                logger.info(f"Wrote environment variables to {env_file_path}")
+            except Exception as e:
+                logger.warning(f"Could not write environment file: {e}")
+        else:
+            logger.info("No NVME_MODELS_ENV_FILE configured, skipping persistent env setup")
 
     def _create_symlinks(self):
         """Create symlinks for backward compatibility."""
@@ -429,6 +471,13 @@ class NVMeStorageManager:
             try:
                 # Create parent directory if needed
                 link_path.parent.mkdir(parents=True, exist_ok=True)
+
+                # Validate symlink target stays within base
+                if not self._validate_path_boundary(target_path, self.nvme_path):
+                    logger.warning(f"Skipping symlink with target outside base: {target_path}")
+                    continue
+                
                 # Remove existing file/directory if it exists
                 if link_path.exists() and not link_path.is_symlink():
                     if link_path.is_dir():
@@ -578,11 +627,13 @@ class NVMeStorageManager:
             result = subprocess.run(
                 ['du', '-sh', str(path)],
                 capture_output=True,
-                text=True
+                text=True,
+                timeout=30,
+                check=False
             )
             if result.returncode == 0:
                 return result.stdout.split()[0]
-        except:
+        except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:
+            logger.debug(f"Failed to get directory size: {e}")
             pass
         return 'unknown'
@@ -599,7 +650,8 @@ class NVMeStorageManager:
         try:
             for ext in extensions:
                 count += len(list(self.nvme_path.rglob(f'*{ext}')))
-        except:
+        except Exception as e:
+            logger.debug(f"Error counting model files: {e}")
             pass
 
         return count
@@ -634,6 +686,43 @@ class NVMeStorageManager:
         return handler.download(model_id, **kwargs)
 
+    def _reserve_disk_space(self, size_gb: int) -> Optional[Path]:
+        """Reserve disk space by creating a sparse file.
+        
+        Args:
+            size_gb: Size to reserve in GB
+            
+        Returns:
+            Path to reservation file, or None if failed
+        """
+        try:
+            reserve_file = self.nvme_path / f'.space_reserve_{os.getpid()}'
+            size_bytes = size_gb * (1024 ** 3)
+            
+            # Create sparse file
+            with open(reserve_file, 'wb') as f:
+                f.seek(size_bytes - 1)
+                f.write(b'\0')
+            
+            # Verify space is actually available
+            usage = self.get_disk_usage()
+            if usage['available_gb'] < self.min_free_space_gb:
+                reserve_file.unlink()
+                return None
+            
+            return reserve_file
+        except Exception as e:
+            logger.error(f"Failed to reserve disk space: {e}")
+            return None
+    
+    def _release_disk_reservation(self, reserve_file: Path):
+        """Release disk space reservation."""
+        try:
+            if reserve_file and reserve_file.exists():
+                reserve_file.unlink()
+        except Exception as e:
+            logger.debug(f"Failed to release reservation: {e}")
+    
     def download_atomic(self, provider: str, model_id: str, target_path: Path) -> Path:
         """Download a model atomically to ensure data integrity.
         
@@ -659,6 +748,7 @@ class NVMeStorageManager:
         # Acquire lock before starting download
         lock_fd = None
         temp_dir = None
+        reserve_file = None
 
         try:
             # Acquire exclusive lock for write operation
@@ -683,12 +773,18 @@ class NVMeStorageManager:
 
             # Check disk space before download
             estimated_size = handler.estimate_model_size(model_id)
             required_space = estimated_size * 2  # Need 2x space for download + move
 
-            if not self.check_disk_space(required_space):
+            # Reserve disk space
+            reserve_file = self._reserve_disk_space(required_space)
+            if not reserve_file:
                 available_gb = self.get_disk_usage()['available_gb']
                 raise IOError(
                     f"Insufficient disk space. Required: {required_space}GB, "
                     f"Available: {available_gb}GB"
                 )
 
@@ -710,8 +806,12 @@ class NVMeStorageManager:
             target_path.parent.mkdir(parents=True, exist_ok=True)
 
+            # Validate target path stays within base
+            if not self._validate_path_boundary(target_path, self.nvme_path):
+                raise SecurityException(f"Target path escapes base directory: {target_path}")
+            
             # Perform atomic move to target location
             logger.info(f"Moving {model_id} to final location: {target_path}")
             shutil.move(str(temp_model_path), str(target_path))
 
@@ -727,8 +827,11 @@ class NVMeStorageManager:
                 except Exception as cleanup_error:
                     logger.warning(f"Failed to clean up temp directory {temp_dir}: {cleanup_error}")
             raise
         finally:
+            # Release disk space reservation
+            if reserve_file:
+                self._release_disk_reservation(reserve_file)
             # Always release the lock
             if lock_fd is not None:
                 self._release_lock(lock_fd)
 
@@ -830,7 +933,8 @@ class NVMeStorageManager:
                 result = subprocess.run(
                     ['ollama', 'list'],
                     capture_output=True,
-                    text=True
+                    text=True,
+                    timeout=30,
+                    check=False
                 )
                 if result.returncode == 0:
                     lines = result.stdout.strip().split('\n')[1:]  # Skip header
@@ -842,7 +946,8 @@ class NVMeStorageManager:
                             'size': parts[1] if len(parts) > 1 else 'unknown',
                             'provider': 'ollama'
                         })
-        except:
+        except Exception as e:
+            logger.debug(f"Failed to list Ollama models: {e}")
             pass
 
         return models
diff --git a/nvme_models/validators.py b/nvme_models/validators.py
index 1234567..abcdefg 100644
--- a/nvme_models/validators.py
+++ b/nvme_models/validators.py
@@ -3,6 +3,7 @@
 import re
 import os
 from pathlib import Path
 from typing import Optional, Tuple
+import subprocess
 import logging
 
 logger = logging.getLogger(__name__)
@@ -14,6 +15,29 @@ class ValidationError(Exception):
     pass
 
 
+def safe_exec(cmd: list, timeout: int = 30, check: bool = True, **kwargs) -> subprocess.CompletedProcess:
+    """Execute subprocess with safety constraints.
+    
+    Args:
+        cmd: Command list to execute
+        timeout: Timeout in seconds (default 30)
+        check: Whether to check return code
+        **kwargs: Additional subprocess.run arguments
+        
+    Returns:
+        CompletedProcess instance
+        
+    Raises:
+        subprocess.TimeoutExpired: If command times out
+        subprocess.CalledProcessError: If check=True and command fails
+    """
+    return subprocess.run(
+        cmd,
+        timeout=timeout,
+        check=check,
+        capture_output=True,
+        text=True,
+        **kwargs
+    )
+
 class Validator:
     """Validates inputs for NVMe model storage operations."""
 
@@ -94,11 +118,17 @@ class Validator:
         """
         try:
             validated_path = Path(path).resolve()
         except Exception as e:
             raise ValidationError(f"Invalid path: {path} - {e}")
 
+        # Check for null bytes and control characters
+        if '\0' in str(path):
+            raise ValidationError(f"Path contains null byte: {path}")
+        
+        # Normalize and resolve symlinks
+        validated_path = validated_path.resolve()
+        
         # Check if path exists (for read operations)
         # Note: We don't check existence for write operations
 
         # If base_path is provided, ensure path is within it
         if base_path:
@@ -106,7 +136,12 @@ class Validator:
                 base = Path(base_path).resolve()
-                if not str(validated_path).startswith(str(base)):
+                # Use is_relative_to for Python 3.9+, fallback to string comparison
+                try:
+                    is_within = validated_path.is_relative_to(base)
+                except AttributeError:
+                    # Python < 3.9 fallback
+                    is_within = str(validated_path).startswith(str(base) + os.sep) or validated_path == base
+                if not is_within:
                     raise ValidationError(
                         f"Path {validated_path} is outside allowed base path {base}"
                     )
             except Exception as e:
@@ -430,10 +465,16 @@ class SecurityValidator:
             return False, error_msg
 
         # Check for command injection attempts
-        dangerous_chars = [';', '|', '&', '$', '`', '(', ')', '{', '}', '<', '>', '\n', '\r', '\0']
+        dangerous_chars = [
+            ';', '|', '&', '$', '`', '(', ')', '{', '}', '<', '>', 
+            '\n', '\r', '\0', '\x00', '\x1a', '\x1b'
+        ]
         for char in dangerous_chars:
             if char in model_id:
-                error_msg = f"Model ID contains dangerous character '{char}': potential command injection attempt"
+                char_repr = repr(char) if ord(char) < 32 else char
+                error_msg = (
+                    f"Model ID contains dangerous character {char_repr}: "
+                    f"potential command injection attempt"
+                )
                 logger.warning(f"Validation failed: {error_msg}")
                 return False, error_msg
 
@@ -443,6 +484,12 @@ class SecurityValidator:
             logger.warning(f"Validation failed: {error_msg}")
             return False, error_msg
 
+        # Check for URL schemes that could be malicious
+        if any(scheme in model_id.lower() for scheme in ['http://', 'https://', 'ftp://', 'file://']):
+            error_msg = f"Model ID contains URL scheme: {model_id}"
+            logger.warning(f"Validation failed: {error_msg}")
+            return False, error_msg
+        
         # Provider-specific validation
         if provider.lower() == 'huggingface':
             # HuggingFace pattern: organization/model-name